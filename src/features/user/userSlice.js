import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { getAddress } from "../../services/apiGeocoding";

function getPosition() {
  return new Promise(function (resolve, reject) {
    navigator.geolocation.getCurrentPosition(resolve, reject);
  });
}

// BASICALLY  WE ARE USING THIS TO GET THE USER ADDRESS AUTOMTICALLY.
// is used for fetching some information about the use address and it do it in 2 steps:

// and this fetchAddress function will become the action creator function, we will later call in our code
// this fetchAddress will be the result of calling createAsyncThunk()
export const fetchAddress = createAsyncThunk(
  // this is action type name
  "user/fetchAddress",
  async function () {
    // 1) We get the user's geolocation position
    const positionObj = await getPosition();
    const position = {
      latitude: positionObj.coords.latitude,
      longitude: positionObj.coords.longitude,
    }; // here we got the user position.

    // 2) Then we use a reverse geocoding API to get a description of the user's address, so we can display it the order form, so that the user can correct it if wrong
    const addressObj = await getAddress(position);
    const address = `${addressObj?.locality}, ${addressObj?.city} ${addressObj?.postcode}, ${addressObj?.countryName}`;

    // 3) Then we return an object with the data that we are interested in. [ that to be used in the order form ]
    // THIS DATA WE ARE RETURNING HERE WILL BECOME THE * payload * OF THE FULLFILLED STATE.and fullfilled state will be handled below by the reducer.
    return { position, address };
  }
);

////
const initialState = {
  username: "",
  status: "idle",
  position: {},
  address: "",
  error: "",
};

const userSlice = createSlice({
  name: "user", // The name: "user" defines the name of the slice in Redux Toolkit.
  initialState,
  reducers: {
    // to update the name we call the updateName() function and which will then mutate the state
    updateName(state, action) {
      state.username = action.payload; // we are using Redux so we can directly mutalte the state.
    },
  },

  // CREATING A THUNKS USING REDUX:
  // here we are handling the three action types produced by the createAsyncThunk() function [depending promice state,fullfilled state,rejected state]
  // HANDLING THE PENDING STATE:
  extraReducers: (builder) =>
    builder
      .addCase(fetchAddress.pending, (state, action) => {
        state.status = "loading";
      })
      // HANDLING THE FULFILLED STATE:
      .addCase(fetchAddress.fulfilled, (state, action) => {
        state.position = action.payload.position;
        state.address = action.payload.address;
        state.status = "idle";
      })
      // HANDLING THE REJECTED STATE:
      .addCase(fetchAddress.rejected, (state, action) => {
        state.status = "error";
        // state.error = action.error.message; //we need some custom error message so we are setting manually.
        state.error =
          "There was a problem getting your address. Make sure to fill this field! ";
      }),
});

export const { updateName } = userSlice.actions; // this is used by dispatcher

export default userSlice.reducer; // the reducer itself we need ,to setup our Redux store.
// this is used by useSelector( ). [ this we are assigning a new name in the store. i,e const store = configureStore({
//  reducer: {
//    user: userReducer, // i am renaming useReducer as a user
//    cart: cartReducer,
//  },
//});

// export const getUsername = (state) => state.user.username;

//// ----COMMENTS------/////

//In Redux toolkit createSlice() the custom hook we are passing an object with the * name * of a Slice and the * initialState * and an object of the our reducers .
// The name field is used as a prefix for action types generated by the slice. For example, when you define the updateName reducer, Redux Toolkit automatically generates an action with a type of "user/updateName".

/// export const { updateName } = userSlice.actions;  [-->  this ** .actions ** contatns an contains an action creators like a updateName() etc...

/// export default userSlice.reducer;  -->
//userSlice.reducer is the final reducer function that Redux uses to handle state updates. It internally uses the functions you defined in reducers: {}.
//reducers: {} in createSlice is where you define your functions (like updateName) that modify the state

////THUNKS:
// **$** A Thunk is a midleware that sits between the dispatching and reducer. It will do something to the dispatched action before updating the store.

// * createAsyncThunk("user/fetchAddress", async function () { } ) --> this createAsyncThunk() will recives the two parameters , first we need to pass an action name and seconde we need to pass an async function that will return the payload for the reducer later. So this function needs to return a promice so an async function is "ideal" here.

// this * createAsyncThunk() * will basically produce a 3 additional action types: 1) one for depending promice state 2) one for the fullfilled state 3) and one for the rejected state . now we need to handle these state in our reducers as follws:

// extraReducers: (builder) =>builder.addCase(fetchAddress.pending,(state, action) => (state.status = "loading")),
// here we are using the pending state(pending,(state, action) => (state.status = "loading")).
// and this is the actual reducer [ (state, action) => (state.status = "loading")]
